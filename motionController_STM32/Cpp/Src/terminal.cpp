//$file${.::terminal.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: MotionController.qm
// File:  ${.::terminal.cpp}
//
// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::terminal.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"             // QP/C++ real-time embedded framework
#include "common.hpp"               // DPP Application interface
#include "bsp.hpp"               // Board Support Package

#include "console.h"
#include "multiLed.hpp"

//$declare${AOs::Terminal} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${AOs::Terminal} ...........................................................
class Terminal : public QP::QActive {
public:
    static Terminal inst;

private:
    QP::QTimeEvt m_timeEvt;

public:
    bool m_gotReply;
    char m_input[20];
    std::uint8_t m_replySize;
    bool m_gotChar;
    std::uint8_t m_maxInputSize;
    QP::QActive * m_AO_Client;
    std::uint16_t m_motorPosition;
    std::uint16_t m_knobPosition;

public:
    Terminal();
    void DispatchCommand(char command);
    void RotateKnobCW();
    void RotateKnobCCW();

protected:
    Q_STATE_DECL(initial);
    Q_STATE_DECL(start);
    Q_STATE_DECL(receiveUserReply);
    Q_STATE_DECL(receivingNextChar);
    Q_STATE_DECL(sendUserPrompt);
}; // class Terminal

} // namespace APP
//$enddecl${AOs::Terminal} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//----------------------------------------------------------------------------
// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_FILE

}

//----------------------------------------------------------------------------
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${Shared::AO_Terminal} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${Shared::AO_Terminal} .....................................................
QP::QActive * const AO_Terminal = &Terminal::inst;

} // namespace APP
//$enddef${Shared::AO_Terminal} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::Terminal} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${AOs::Terminal} ...........................................................
Terminal Terminal::inst;

//${AOs::Terminal::Terminal} .................................................
Terminal::Terminal()
  : QActive(Q_STATE_CAST(&initial)),
    m_timeEvt(this, TIMEOUT_SIG, 0U)
{}

//${AOs::Terminal::DispatchCommand} ..........................................
void Terminal::DispatchCommand(char command) {
    // Read the incoming byte
    // Notify App if ped event selected.
    MoveEvt *pe = 0;
    KnobEvt *ke = 0;

    switch ( command ) {
        case 'f':
        case 'F':
            pe = Q_NEW(MoveEvt, FIND_LIMIT_SIG);
            pe->position = -4000;
            AO_MotionMgr->POST(pe, this);
            break;
        case 'h':
        case 'H':
            pe = Q_NEW(MoveEvt, HOME_SIG);
            AO_MotionMgr->POST(pe, this);
            break;
        case 'm':
        case 'M':
            pe = Q_NEW(MoveEvt, MOVE_SIG);
            pe->position = 1000;
            AO_Motor->POST(pe, this);
            break;
        case 'k':
        case 'K':
            RotateKnobCW();
            ke = Q_NEW(KnobEvt, KNOB_SIG);
            ke->position = m_knobPosition;
            AO_Knob->POST(ke, this);
            break;
        case 'j':
        case 'J':
            RotateKnobCCW();
            ke = Q_NEW(KnobEvt, KNOB_SIG);
            ke->position = m_knobPosition;
            AO_Knob->POST(ke, this);
            break;
        case 's':
        case 'S':
            pe = Q_NEW(MoveEvt, STOP_SIG);
            AO_Motor->POST(pe, this);
            break;
        case 'u':
        case 'U':
            pe = Q_NEW(MoveEvt, SHOW_STATE_SIG);
            AO_Motor->POST(pe, this);
            break;
        case '+':
            m_motorPosition += 1000;
            pe = Q_NEW(MoveEvt, MOVE_SIG);
            pe->position = m_motorPosition;
            AO_Motor->POST(pe, this);
            break;
        case '-':
            m_motorPosition -= 1000;
            pe = Q_NEW(MoveEvt, MOVE_SIG);
            pe->position = m_motorPosition;
            AO_Motor->POST(pe, this);
            break;
    }

}

//${AOs::Terminal::RotateKnobCW} .............................................
void Terminal::RotateKnobCW() {
    m_knobPosition += 1;
}

//${AOs::Terminal::RotateKnobCCW} ............................................
void Terminal::RotateKnobCCW() {
    m_knobPosition -= 1;
}

//${AOs::Terminal::SM} .......................................................
Q_STATE_DEF(Terminal, initial) {
    //${AOs::Terminal::SM::initial}
    //consoleDisplay("Terminal running\r\n");
    m_maxInputSize = sizeof(m_input)/sizeof(m_input[0]);
    m_AO_Client = Q_EVT_CAST(ClientEvt)->client;
    m_motorPosition = 1000;
    m_knobPosition = 1;
    consoleDisplay("Terminal: starting\r\n");
    return tran(&start);
}

//${AOs::Terminal::SM::start} ................................................
Q_STATE_DEF(Terminal, start) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Terminal::SM::start}
        case Q_ENTRY_SIG: {
            //consoleDisplay("Terminal ::Idle\r\n");
            m_timeEvt.armX(1000, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::start}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::start::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&sendUserPrompt);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

//${AOs::Terminal::SM::receiveUserReply} .....................................
Q_STATE_DEF(Terminal, receiveUserReply) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Terminal::SM::receiveUserReply}
        case Q_ENTRY_SIG: {
            //consoleDisplay("Terminal ::Receiving USART\r\n");
            m_gotReply = false;
            m_gotChar = false;
            m_replySize = 0;
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::receiveUserReply::initial}
        case Q_INIT_SIG: {
            m_gotReply = false;
            m_gotChar = true;
            m_replySize = 0;

            consoleReadAsyncInit();
            status_ = tran(&receivingNextChar);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

//${AOs::Terminal::SM::receiveUserReply::receivingNextChar} ..................
Q_STATE_DEF(Terminal, receivingNextChar) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Terminal::SM::receiveUserReply::receivingNextChar}
        case Q_ENTRY_SIG: {
            if ( m_gotChar )
            {
                m_gotChar = false;
                consoleReadByteAsync();
            }

            m_timeEvt.armX(300, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::receiveUserReply::receivingNextChar}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::receiveUserReply::receivingNextCha~::TIMEOUT}
        case TIMEOUT_SIG: {
            m_gotChar = (consoleInputReady()) ? true : false;

            if ( m_gotChar )
            {
                m_gotReply = (consoleInputDone()) ? true : false;
            }
            //${AOs::Terminal::SM::receiveUserReply::receivingNextCha~::TIMEOUT::[NotDone]}
            if (!m_gotReply) {
                status_ = tran(&receivingNextChar);
            }
            //${AOs::Terminal::SM::receiveUserReply::receivingNextCha~::TIMEOUT::[GotReply]}
            else if (m_gotReply) {
                m_replySize = consoleReadString(m_input, m_maxInputSize);
                consoleDisplay("\r\n");
                consoleDisplay(m_input);
                DispatchCommand(m_input[0]);
                status_ = tran(&sendUserPrompt);
            }
            else {
                status_ = Q_RET_UNHANDLED;
            }
            break;
        }
        default: {
            status_ = super(&receiveUserReply);
            break;
        }
    }
    return status_;
}

//${AOs::Terminal::SM::sendUserPrompt} .......................................
Q_STATE_DEF(Terminal, sendUserPrompt) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Terminal::SM::sendUserPrompt}
        case Q_ENTRY_SIG: {
            m_timeEvt.armX(500, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::sendUserPrompt}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::sendUserPrompt::TIMEOUT}
        case TIMEOUT_SIG: {
            consoleDisplay("Enter command: ");
            status_ = tran(&receiveUserReply);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

} // namespace APP
//$enddef${AOs::Terminal} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
