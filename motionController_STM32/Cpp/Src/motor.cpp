//$file${.::motor.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: MotionController.qm
// File:  ${.::motor.cpp}
//
// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::motor.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"             // QP/C++ real-time embedded framework

#include "console.h"
#include "common.hpp"
#include "motion.h"
#include "motor.hpp"               // DPP Application interface
#include "bsp.hpp"               // Board Support Package

//----------------------------------------------------------------------------
// ask QM to declare the Motor class
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${Shared::AO_Motor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${Shared::AO_Motor} ........................................................
QP::QActive * const AO_Motor = &Motor::inst;

} // namespace APP
//$enddef${Shared::AO_Motor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::Motor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${AOs::Motor} ..............................................................
Motor Motor::inst;

//${AOs::Motor::MotionDone} ..................................................
std::int8_t Motor::MotionDone() {
    return AtDestination();
}

//${AOs::Motor::MoveMotor} ...................................................
std::int16_t Motor::MoveMotor() {
    /////////////////
    // Note!!
    // If the stepper motor is running continuously for multiple steps,
    // it prevents the timer event loop from processing events;
    // consequently the timer events must be paused if the stepper runs
    // multiple steps or else the event queue is overloaded.
    // The timer can remain enabled if the foreground code runs
    // one step at a time; consequently this method moves only one
    // step at a time.
    /////////////////
    // Only one step at a time now.
    int16_t increment = (m_positionRequest >= m_position) ? 1 : -1;
    m_position = BSP_MoveMotor(increment);
    return m_position;
}

//${AOs::Motor::CreateOneShotTimer} ..........................................
void Motor::CreateOneShotTimer(uint32_t time) {
    // Create one shot timer
    //QTimeEvt_ctorX(&me->timeEvt, &me->super, MOVE_TIME_SIG, 0U);
    //QTimeEvt_armX(&me->timeEvt, time, 0);
    m_timeEvt.armX(time, 0U);
}

//${AOs::Motor::SendMotionDoneEvent} .........................................
void Motor::SendMotionDoneEvent() {
    // Notify client motion done
    MovedEvt *myEvt = Q_NEW(MovedEvt, MOVED_SIG);
    myEvt->position = m_position;
    m_AO_Client->POST(myEvt, this);
}

//${AOs::Motor::SendMotionErrorEvent} ........................................
void Motor::SendMotionErrorEvent() {
    // Notify client motion error
    MoveErrorEvt *myEvt = Q_NEW(MoveErrorEvt, MOVE_ERROR_SIG);
    myEvt->position = m_position;
    myEvt->error = m_error;
    m_AO_Client->POST(myEvt, this);
}

//${AOs::Motor::Motor} .......................................................
Motor::Motor()
  : QActive(Q_STATE_CAST(&initial)),
    m_timeEvt(this, MOVE_TIME_SIG, 0U)
{
    m_stepDelay = BSP_getMotorStepDelay();
    m_positionRequest = 0;
    m_increment = 0;
    m_position = 0;
    m_atLimitSwitch = 0;
    m_findingLimit = 0;
    m_moving = 0;
}

//${AOs::Motor::PublishPositionEvent} ........................................
void Motor::PublishPositionEvent() {
    // Publish position of motor
    PositionEvt *myEvt = Q_NEW(PositionEvt, CUSTOM_SIG);
    myEvt->position = m_position;
    myEvt->device = AO_MOTOR;
    myEvt->error = m_error;
    QP::QActive::PUBLISH(myEvt, this);
}

//${AOs::Motor::AtDestination} ...............................................
bool Motor::AtDestination() {
    return m_position == m_positionRequest;
}

//${AOs::Motor::SendMotorStoppedMessage} .....................................
void Motor::SendMotorStoppedMessage() {
    consoleDisplayArgs("Motor: stopped, position: %d;\r\n", m_position);
}

//${AOs::Motor::SendMotorPositionMessage} ....................................
void Motor::SendMotorPositionMessage() {
    consoleDisplayArgs("Motor: position: %d, moving: %d, limit: %d;\r\n",
        m_position, m_moving, m_atLimitSwitch);
}

//${AOs::Motor::SendOffEvent} ................................................
void Motor::SendOffEvent(uint16_t position) {
    // Request new motor postiion
    MoveEvt *myEvt = Q_NEW(MoveEvt, OFF_SIG);
    m_AO_Client->POST(myEvt, this);
}

//${AOs::Motor::SM} ..........................................................
Q_STATE_DEF(Motor, initial) {
    //${AOs::Motor::SM::initial}
    m_AO_Client = Q_EVT_CAST(ClientEvt)->client;
    subscribe(SHOW_STATE_SIG);
    return tran(&MotionReady);
}

//${AOs::Motor::SM::MotionReady} .............................................
Q_STATE_DEF(Motor, MotionReady) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Motor::SM::MotionReady::initial}
        case Q_INIT_SIG: {
            consoleDisplay("Motor: starting;\r\n");
            m_measure.Initialize(0,0,0);
            m_measure.Run();
            m_atLimitSwitch = 0;
            status_ = tran(&Stopped);
            break;
        }
        //${AOs::Motor::SM::MotionReady::SWITCH_CHANGED}
        case SWITCH_CHANGED_SIG: {
            uint8_t switchState = Q_EVT_CAST(SwitchEvt)->state;

            if ( switchState == 0 ) {
                if ( m_increment < 0 && m_atLimitSwitch == 0 ) {
                    consoleDisplay("Motor: limit switch closed;\r\n");
                }
                m_atLimitSwitch = 1;
            }
            else if ( switchState == 1 ) {
                m_atLimitSwitch = 0;
            }
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Motor::SM::MotionReady::SHOW_STATE}
        case SHOW_STATE_SIG: {
            //SendMotorPositionMessage();
            PublishPositionEvent();
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

//${AOs::Motor::SM::MotionReady::Moving} .....................................
Q_STATE_DEF(Motor, Moving) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Motor::SM::MotionReady::Moving}
        case Q_ENTRY_SIG: {
            //consoleDisplay("Motor: moving");
            m_moving = 1;
            uint32_t moveTime = 15;
            CreateOneShotTimer(moveTime);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Motor::SM::MotionReady::Moving}
        case Q_EXIT_SIG: {
            //consoleDisplay("Motor: not moving");
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Motor::SM::MotionReady::Moving::STOP}
        case STOP_SIG: {
            m_error = ERROR_STOP;
            status_ = tran(&Stopped);
            break;
        }
        //${AOs::Motor::SM::MotionReady::Moving::MOVE_TIME}
        case MOVE_TIME_SIG: {
            //consoleDisplay("Motor: move motor");
            MoveMotor();
            //${AOs::Motor::SM::MotionReady::Moving::MOVE_TIME::[MotionDone]}
            if (AtDestination()) {
                m_measure.UpdateElapsedTime();
                //m_measure.DisplayElapsedTimeDelta();
                status_ = tran(&Stopped);
            }
            //${AOs::Motor::SM::MotionReady::Moving::MOVE_TIME::[else]}
            else {
                //${AOs::Motor::SM::MotionReady::Moving::MOVE_TIME::[else]::[AtLimitSwitch]}
                if (m_atLimitSwitch == 1) {
                    consoleDisplay("Motor: stopped by limit switch;\r\n");

                    if ( m_findingLimit ) {
                        consoleDisplay("Motor: found switch, setting home position;\r\n");
                        m_foundLimitSwitch = true;
                        m_position = 0;
                    }
                    else {
                        m_error = ERROR_LIMIT_SWITCH;
                    }
                    status_ = tran(&Stopped);
                }
                //${AOs::Motor::SM::MotionReady::Moving::MOVE_TIME::[else]::[else]}
                else {
                    status_ = tran(&Moving);
                }
            }
            break;
        }
        default: {
            status_ = super(&MotionReady);
            break;
        }
    }
    return status_;
}

//${AOs::Motor::SM::MotionReady::Stopped} ....................................
Q_STATE_DEF(Motor, Stopped) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Motor::SM::MotionReady::Stopped}
        case Q_ENTRY_SIG: {
            if ( m_moving ) {
                if ( m_error == ERROR_NONE ) {
                    SendMotionDoneEvent();
                }
                else {
                    SendMotionErrorEvent();
                }

                m_findingLimit = 0;
                m_moving = 0;
            }

            PublishPositionEvent();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Motor::SM::MotionReady::Stopped::MOVE, FIND_LIMIT}
        case MOVE_SIG: // intentionally fall through
        case FIND_LIMIT_SIG: {
            int16_t newPosition = Q_EVT_CAST(MoveEvt)->position;
            m_positionRequest = newPosition;
            m_increment = m_positionRequest - m_position;
            m_foundLimitSwitch = false;
            m_error = ERROR_NONE;

            if ( Q_EVT_CAST(MoveEvt)->sig == FIND_LIMIT_SIG )
            {
                consoleDisplay("Motor: finding limit;\r\n");
                m_findingLimit = 1;
            }

            //consoleDisplayArgs("Motor: requested position: %d, position: %d;\r\n",
            //    newPosition, m_position);
            //${AOs::Motor::SM::MotionReady::Stopped::MOVE, FIND_LIMIT::[AtPositionOrAtLimit]}
            if (AtDestination() || (m_increment < 0 && m_atLimitSwitch)) {
                if ( m_atLimitSwitch )
                {
                    //consoleDisplay("Motor: no move, at limit switch;\r\n");
                }
                else
                {
                    //consoleDisplay("Motor: no move, already at position;\r\n");
                }

                SendMotionDoneEvent();
                status_ = tran(&Stopped);
            }
            //${AOs::Motor::SM::MotionReady::Stopped::MOVE, FIND_LIMIT::[NewPosition]}
            else if (!AtDestination()) {
                //consoleDisplayArgs("Motor: moving, increment: %d;\r\n", m_increment);
                m_measure.Start();
                status_ = tran(&Moving);
            }
            else {
                status_ = Q_RET_UNHANDLED;
            }
            break;
        }
        //${AOs::Motor::SM::MotionReady::Stopped::OFF}
        case OFF_SIG: {
            // Disable motor.
            BSP_enableMotor(0);
            // Send command completion message
            SendMotionDoneEvent();
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = super(&MotionReady);
            break;
        }
    }
    return status_;
}

} // namespace APP
//$enddef${AOs::Motor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
